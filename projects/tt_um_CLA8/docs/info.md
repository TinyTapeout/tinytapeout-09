<!---

This file is used to generate your project datasheet. Please fill in the information below and delete any unused
sections.

You can also include images in this folder and reference them in the markdown. Each image must be less than
512 kb in size, and the combined size of all images must be less than 1 MB.
-->

## How it works

A carry-lookahead adder (CLA) is a type of adder designed for fast speeds. First, it calculates the propagate and generate signals. The propagate signal determines if a carry bit can propagate through to the next bit, and the generate signal bit determines if there is a carry bit. As the name implies, a carry-lookahead adder works by generating a carry bit for every bit in the sum. This works by determining every possible way a carry bit can be generated by combining the generate and propagate signal from previous bits. The equations for the propagate, generate, sum, and carry bit are shown below:

![image](https://github.com/user-attachments/assets/08c25f47-c7e1-4f3d-bdf7-c41eaf33e2fd)

The calculations for the propagate, generate, and sum signals are trivial, but the calculation for the carry bit is dependent on its value in the previous bit, which makes it more complicated to solve. For example, all of the carry bits in a 4-bit CLA adder can be seen in the equation and diagram below:

![image](https://github.com/user-attachments/assets/4da94fc2-f0ff-4652-86f2-8dcdcfdabf8d)

![image](https://github.com/user-attachments/assets/fc4752cd-b898-4df2-bf8b-331ee433b8ee)

By calculating the carry bits by using combinatorial logic, a CLA is able to calculate all of the carry bits of the sum without relying on sequential operations, unlike a ripple carry adder. The main time complexity of the ripple carry adder is based on the implementation of the last (and largest) AND gate of the most significant carry bit in the combinatorial equation. This AND gate has n+1 inputs, where n is the bits of the input. The implementation of multiple input AND gates in hardware consists of multiple smaller input AND gates organized in a tree structure, which inherently has a logarithmic time complexity. This logic extends to the CLA which possesses a logarithmic time complexity, and it makes CLAs viewed as one of the fastest implementations of digital adders due to its combinatorial nature. CLAs that calculate large bit-widths can also be designed by using multiple CLAs with smaller bit-widths in parallel to calculate intermediate values. This implementation using a tree structure of adders allows CLAs to also possess a modular design which can be scaled up to handle large bit-widths. However, this tree-like design is an implementation that other parallel prefix adders such as the Kogge-Stone adder utilize to a greater effect. Although CLAs are praised for their speed, it comes at the cost of a large area, as the components needed to calculate the carry bits for larger bit-widths become exponentially larger.

The CLA in this project is an 8-bit adder that does not utilize the implementation using smaller CLAs; rather, it is a fully combinatorial circuit to calculate all 8 bits of the carry signal.

## How to test

ui_in[7:0] is addend 1, and uio_in[7:0] is addend 2. ui_out[7:0] is sum.

The adder was tested using all possible pairs of integers from 0 to 255 as inputs, which resulted in 25536 test cases total. For example, the adder would use 0x25 and 0xD7 as inputs, add them up to 0xFC, and the result would be checked to make sure it was the correct output. Carry out was not checked as there is no output pin for a carry out on the board.

## External hardware

No external hardware needed.
